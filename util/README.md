<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# util

```go
import "github.com/KEINOS/go-utiles/util"
```

## Index

- [Variables](<#variables>)
- [func ChDir(pathDir string) (deferReturn func())](<#func-chdir>)
- [func ChDirHome() func()](<#func-chdirhome>)
- [func CreateTemp(dir string, pattern string) (*os.File, error)](<#func-createtemp>)
- [func ExitOnErr(err error)](<#func-exitonerr>)
- [func FmtStructPretty(val interface{}, prefixes ...string) string](<#func-fmtstructpretty>)
- [func GetMods() []map[string]string](<#func-getmods>)
- [func GetNameBin() string](<#func-getnamebin>)
- [func HashBLAKE3(input string, lenHash int) (hashed string, err error)](<#func-hashblake3>)
- [func HashStruct(input interface{}, lenHash int) (string, error)](<#func-hashstruct>)
- [func IsDir(pathFile string) bool](<#func-isdir>)
- [func IsFile(pathFile string) bool](<#func-isfile>)
- [func IsNameFileJSON(name string) bool](<#func-isnamefilejson>)
- [func PathExists(path string) bool](<#func-pathexists>)
- [func RandStr(length int) string](<#func-randstr>)
- [func ReadFile(path string) ([]byte, error)](<#func-readfile>)
- [func UniqSliceString(input []string) []string](<#func-uniqslicestring>)
- [func WriteTmpFile(data string) (pathSaved string, funcCleanUp func(), err error)](<#func-writetmpfile>)


## Variables

```go
var (
    // OsGetwd is a copy of os.Getwd to ease mocking during test.
    //
    // All functions of this package that needs to use os.Getwd uses OsGetwd instead.
    // See the example in the test of ChDir for how-to-mock.
    OsGetwd = os.Getwd
    // OsChdir is a copy of os.Chdir to ease mocking during test.
    //
    // All functions of this package that needs to use os.Chdir uses OsChdir instead.
    // See the example in the test of ChDir for how-to-mock.
    OsChdir = os.Chdir
)
```

OsExit is a copy of os\.Exit to ease mocking during test\.

All functions of this package that needs to use os\.Exit uses OsExit instead\. See the example of ExitOnError for how\-to\-mock\.

```go
var OsExit = os.Exit
```

ReadBuildInfo is a copy of debug\.ReadBuildInfo to ease mocking during test for GetMods\.

This package uses this util\.ReadBuildInfo insetead of debug\.ReadBuildInfo\.

```go
var ReadBuildInfo = debug.ReadBuildInfo
```

## func ChDir

```go
func ChDir(pathDir string) (deferReturn func())
```

ChDir changes the current working directory to the given path in one\-go\. It returns a function which moves back to the original directory\.

Note: This function exits with status 1 if any error happens\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
	"log"
	"os"
)

func main() {
	pathDirToMove := "/tmp"

	// Move working directory and defer switch back the diretory
	funcReturn := util.ChDir(pathDirToMove)
	defer funcReturn()

	pathDirCurrent, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(pathDirCurrent)
}
```

#### Output

```
/tmp
```

</p>
</details>

## func ChDirHome

```go
func ChDirHome() func()
```

ChDirHome is similar to util\.ChDir but it moves the current working directory to the user's home directory in one\-go\. It returns a function to move back to the original directory\.

Note: This function exits with status 1 if any error happens\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
	"log"
	"os"
)

func main() {
	// Move to current user home dir and defer moving back to original
	funcReturn := util.ChDirHome()
	defer funcReturn()

	/* Get dir infos to check if the current dir is user's home */
	pathDirHome, err := os.UserHomeDir()
	if err != nil {
		log.Fatal(err)
	}

	pathDirCurr, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	// Assert
	if pathDirCurr == pathDirHome {
		fmt.Println("moved to user's home dir")
	} else {
		log.Fatalf("failed to move dir. Home: %v, Current: %v", pathDirHome, pathDirCurr)
	}

}
```

#### Output

```
moved to user's home dir
```

</p>
</details>

## func CreateTemp

```go
func CreateTemp(dir string, pattern string) (*os.File, error)
```

CreateTemp is similar to os\.CreateTemp in Go 1\.16\+ but for compatibility with Go 1\.14 and 1\.15\.

It creates a new temporary file in the existing directory dir\, opens the file for reading and writing\, and returns the resulting file\.

The filename is generated by taking pattern and adding a random string to the end\.

If pattern includes a "\*"\, the random string replaces the last "\*"\. If dir is the empty string\, CreateTemp uses the default directory for temporary files\, as returned by os\.TempDir\.

Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file\. The caller can use the file's Name method to find the pathname of the file\. It is the caller's responsibility to remove the file when it is no longer needed\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
	"log"
	"os"
)

func main() {
	// Create temp file under temp dir with the name "foo-*.json"
	p, err := util.CreateTemp("", "foo-*.json")
	if err != nil {
		log.Fatalf("%v", err)
	}
	defer p.Close() // Don't forget to close it

	pathSaved := p.Name() // Get the file path

	// Do  something with the file
	if util.IsFile(pathSaved) {
		fmt.Println("file exists")
	}

	// Clean up the temp file
	os.Remove(pathSaved)

	if !util.IsFile(pathSaved) {
		fmt.Println("temp file cleaned")
	}

}
```

#### Output

```
file exists
temp file cleaned
```

</p>
</details>

## func ExitOnErr

```go
func ExitOnErr(err error)
```

ExitOnErr exits with status 1 if err is not nil\.

To test this function\, mock the OsExit function variable\. See ExitOnError\_test\.go for an example\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"errors"
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	/*
		Example to mock OsExit in ExitOnErr
	*/
	// Backup and defer restoration
	oldOsExit := util.OsExit
	defer func() {
		util.OsExit = oldOsExit
	}()

	// Mock OsExit
	util.OsExit = func(code int) {
		fmt.Println("the exit code was:", code)
	}

	// Create error
	err := errors.New("foo")

	util.ExitOnErr(err)

}
```

#### Output

```
the exit code was: 1
```

</p>
</details>

## func FmtStructPretty

```go
func FmtStructPretty(val interface{}, prefixes ...string) string
```

FmtStructPretty formats JSON string or an object into pretty\-indented JSON\-strings\.

If a prefix is provided then it will add the prefix to each line\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	data := struct {
		Foo string `json:"foo" mapstructure:"foo"`
	}{
		Foo: "bar",
	}

	prettyJSON := util.FmtStructPretty(data)

	fmt.Println(prettyJSON)
}
```

#### Output

```
{
  "foo": "bar"
}
```

</p>
</details>

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	data := []string{
		"foo",
		"bar",
	}

	prettyJSON := util.FmtStructPretty(data)

	fmt.Println(prettyJSON)
}
```

#### Output

```
[
  "foo",
  "bar"
]
```

</p>
</details>

## func GetMods

```go
func GetMods() []map[string]string
```

GetMods returns a list of external modules used in the package\. The list contains: module name\, path and the version\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	listMods := util.GetMods()

	for _, modInfo := range listMods {
		fmt.Println(modInfo["name"])
		fmt.Println(modInfo["path"])
		fmt.Println(modInfo["version"])
	}
}
```

#### Output

```
a
n/a
n/a
```

</p>
</details>

## func GetNameBin

```go
func GetNameBin() string
```

GetNameBin returns the file name of the current executable binary\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	nameBin := util.GetNameBin()

	fmt.Println(nameBin)

}
```

#### Output

```
util.test
```

</p>
</details>

## func HashBLAKE3

```go
func HashBLAKE3(input string, lenHash int) (hashed string, err error)
```

HashBLAKE3 returns the hashed value of "input" with length of "lenHash"\. The lenHash must be in the range between 1\-1024\.

The hash algorithm is based on BLAKE3 so it is fast but NOT suitable for cryptographic purposes\. Only suitable for hashing a small range of values such as IDs or temporary values\.

The input will be hashed with BLAKE3 algorithm then encodes it to Base58 \(Base58BTC\) and returns the first "lenHash" bytes of the results\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
	"log"
)

func main() {
	input := "foo"
	lenHash := 16

	hashed, err := util.HashBLAKE3(input, lenHash)
	if err != nil {
		// Do something with the error
		log.Fatalf("failed to hash: %v", err)
	}

	fmt.Println("Hashed value:", hashed)
	fmt.Println("Length:", len(hashed))
}
```

#### Output

```
Hashed value: 7STCqaLBnDB6EKXi
Length: 16
```

</p>
</details>

## func HashStruct

```go
func HashStruct(input interface{}, lenHash int) (string, error)
```

GetHashStruct returns the hash value of the input struct with the given length\.

Note that the hash value is only for change detection purposes and NOT to detect falsification\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
	"log"
)

func main() {
	data := struct {
		Foo string
		Bar int
	}{
		Foo: "hoge fuga",
		Bar: 1,
	}

	hash1, err := util.HashStruct(data, 16) // 16 char length
	if err != nil {
		log.Fatalf("hash error: %v", err)
	}

	fmt.Println("Hash value before change:", hash1)

	data.Bar = 2 // Change value

	hash2, err := util.HashStruct(data, 16) // 16 char length
	if err != nil {
		log.Fatalf("hash error: %v", err)
	}

	fmt.Println("Hash value after change :", hash2)

}
```

#### Output

```
Hash value before change: 4KcWDdX1qXnGBV4U
Hash value after change : 6aESjhTWhk3Tv91h
```

</p>
</details>

## func IsDir

```go
func IsDir(pathFile string) bool
```

IsDir returns true if pathFile is an existing directory and not a file\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	// Existing dir
	if util.IsDir("../testdata/sample_data") {
		fmt.Println("is dir")
	}

	// Not existing dir
	if !util.IsDir("./foobar") {
		fmt.Println("not a dir")
	}

	// File exists but not a dir
	if !util.IsDir("./IsDir_test.go") {
		fmt.Println("not a dir")
	}

}
```

#### Output

```
is dir
not a dir
not a dir
```

</p>
</details>

## func IsFile

```go
func IsFile(pathFile string) bool
```

IsFile returns true if file exists in the given path\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	fmt.Println(util.IsFile("./IsFile_test.go"))
	fmt.Println(util.IsFile("./non-existing-file.txt"))
	fmt.Println(util.IsFile("../util")) // Existing but is a dir

}
```

#### Output

```
true
false
false
```

</p>
</details>

## func IsNameFileJSON

```go
func IsNameFileJSON(name string) bool
```

IsNameFileJSON returns true if name is a file path and ends with "\.json"\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	if target := "/foo/bar/buz.json"; util.IsNameFileJSON(target) {
		fmt.Println(target, "is a JSON file")
	}

}
```

#### Output

```
/foo/bar/buz.json is a JSON file
```

</p>
</details>

## func PathExists

```go
func PathExists(path string) bool
```

PathExists returns true if the path is an existing file or dir\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	fmt.Println(util.PathExists("./PathExists_test.go"))
	fmt.Println(util.PathExists("../util"))
	fmt.Println(util.PathExists("./non-existing"))

}
```

#### Output

```
true
true
false
```

</p>
</details>

## func RandStr

```go
func RandStr(length int) string
```

RandStr returns a random unique string with the given length\. The length range must be between 1\-1024\. Otherwise it will os\.Exit with status 1\.

Note that\, it is a pseudo\-random string generator and unsuitable for security\-sensitive work\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
	"log"
)

func main() {
	length := 16

	for i := 0; i < 1000; i++ {
		h1 := util.RandStr(length)
		h2 := util.RandStr(length)

		if h1 == h2 {
			log.Fatalf("the result did collide\nh1: %v\nh2: %v\n", h1, h2)
		}
	}

	fmt.Println("ok")
}
```

#### Output

```
ok
```

</p>
</details>

## func ReadFile

```go
func ReadFile(path string) ([]byte, error)
```

ReadFile is similar to os\.ReadFile inf Go v1\.16\+\. Aim to use for Go v1\.14 and 1\.15 compatibility\.

## func UniqSliceString

```go
func UniqSliceString(input []string) []string
```

UniqSliceString removes duplicate values of a given slice and returns a slice with unique values\. The order remains the same as the original\.

Issue: https://qiitadon.com/web/statuses/106158855888548864 Ref: https://qiitadon.com/web/statuses/106158948168528024

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
)

func main() {
	data := []string{
		"one",
		"one",
		"two",
		"two",
		"three",
		"three",
	}
	fmt.Println(util.UniqSliceString(data))
}
```

#### Output

```
[one two three]
```

</p>
</details>

## func WriteTmpFile

```go
func WriteTmpFile(data string) (pathSaved string, funcCleanUp func(), err error)
```

WriteTmpFile saves the string of data to a temp file\. It returns the saved path and a function to delete that temp file\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/KEINOS/go-utiles/util"
	"log"
)

func main() {
	data := "foo bar"

	pathFile, deferCleanUp, err := util.WriteTmpFile(data)
	if err != nil {
		log.Fatal(err)
	}

	defer deferCleanUp()

	read, err := util.ReadFile(pathFile)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(string(read))
}
```

#### Output

```
foo bar
```

</p>
</details>



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
